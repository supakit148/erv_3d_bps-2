<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <title>ERV 3D + Parameters | BPS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; height:100%; background:#0b0f1a; font-family: "Prompt", system-ui, sans-serif; color:#fff; }
    #scene { position:fixed; inset:0; }

    /* ===== Fixed UI (4 มุม) ===== */
    .hud { position:absolute; inset:0; pointer-events:none; }
    .card {
      width: 200px; pointer-events:auto;
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 14px; padding: 10px 14px; backdrop-filter: blur(10px);
      box-shadow: 0 8px 28px rgba(0,0,0,0.35);
    }
    .title { font-size: 12px; letter-spacing: .12em; opacity:.8; text-transform: uppercase; }
    .val { display:flex; gap:10px; align-items:baseline; margin-top:6px; }
    .t { font-size: 28px; font-weight: 700; }
    .h { font-size: 14px; opacity:.85; }
    .badge { font-size: 11px; padding:2px 8px; border-radius: 999px; opacity:.9; }
    .warm { background: rgba(184,50,26,.18); color: #ffb7a8; border:1px solid rgba(184,50,26,.35); }
    .cool { background: rgba(24,116,210,.18); color: #a9d2ff; border:1px solid rgba(24,116,210,.35); }
    /* ตำแหน่ง 4 มุม */
    .tl { position:absolute; top:18px; left:18px; }
    .tr { position:absolute; top:18px; right:18px; }
    .bl { position:absolute; bottom:18px; left:18px; }
    .br { position:absolute; bottom:18px; right:18px; }

    /* ===== Toggle / Header ===== */
    .topbar {
      position: absolute; top:14px; left:50%; transform:translateX(-50%);
      display:flex; gap:10px; pointer-events:auto;
    }
    .btn {
      background: #141b2b; color:#cfe6ff; border:1px solid #21314d;
      padding: 8px 14px; border-radius: 12px; cursor:pointer;
    }
    .btn.active { background:#1f2a44; border-color:#2f4d7a; }
    .label-legend {
      position:absolute; bottom:20px; left:50%; transform:translateX(-50%); pointer-events:none;
      font-size:12px; color:#9bb6d8; opacity:.9;
    }

    /* ป้าย 3D (CSS2D) */
    .tag {
      background: rgba(8,12,24,.7);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 10px; padding: 6px 10px;
      box-shadow: 0 8px 18px rgba(0,0,0,.35);
      white-space: nowrap;
      font-size: 12px;
    }
    .tag .t3d { font-size:16px; font-weight:700; margin-right:8px; }
    .tag .rh { opacity:.85; font-size:12px; }
    .tag.warm { color:#ffb7a8; border-color: rgba(184,50,26,.35); }
    .tag.cool { color:#a9d2ff; border-color: rgba(24,116,210,.35); }

    /* ===== Overlay ===== */
    .overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
      padding: 40px;
      color: rgba(255, 255, 255, 0.9);
      text-align: center;
      background: linear-gradient(180deg, rgba(11,15,26,0.2) 0%, rgba(11,15,26,0.0) 60%);
    }

    .sub {
      font-size: 14px;
      letter-spacing: 3px;
      text-transform: uppercase;
      color: rgba(255,255,255,0.6);
      margin-top: 30px;
    }

    .header {
      font-size: 28px;
      font-weight: 600;
      text-shadow: 0 4px 12px rgba(0,0,0,0.5);
      color: #ffffffd9;
    }

    .footer {
      font-size: 13px;
      color: rgba(255,255,255,0.6);
      background: rgba(255,255,255,0.05);
      padding: 8px 16px;
      border-radius: 12px;
      backdrop-filter: blur(6px);
    }
  </style>
</head>
<body>
  <div id="scene"></div>

  <!-- ✅ Overlay -->
  <div class="overlay">
    <div class="sub">ERV Air-to-Air Heat Exchanger</div>
    <div class="header">Real-time 3D Flow Simulation</div>
    <div class="footer">Drag to look around • Auto-rotate enabled</div>
  </div>

  <!-- ===== Fixed UI Mode (สี่มุม) ===== -->
  <div id="fixedHud" class="hud">
    <div class="card tl">
      <div class="title">Warm Inlet</div>
      <div class="val"><span id="fiT" class="t">–</span><span id="fiH" class="h">–</span></div>
      <span class="badge warm">ท่อซ้าย: แดงเข้ม → ฟ้าเข้ม</span>
    </div>
    <div class="card tr">
      <div class="title">Warm Outlet</div>
      <div class="val"><span id="foT" class="t">–</span><span id="foH" class="h">–</span></div>
      <span class="badge warm">ใกล้ core อุ่นลง</span>
    </div>
    <div class="card bl">
      <div class="title">Cool Inlet</div>
      <div class="val"><span id="ciT" class="t">–</span><span id="ciH" class="h">–</span></div>
      <span class="badge cool">ท่อขวา: ฟ้าเข้ม → แดงเข้ม</span>
    </div>
    <div class="card br">
      <div class="title">Cool Outlet</div>
      <div class="val"><span id="coT" class="t">–</span><span id="coH" class="h">–</span></div>
      <span class="badge cool">ใกล้ core อุ่นขึ้น</span>
    </div>
  </div>

  <!-- Toggle Mode -->
  <div class="topbar">
    <button id="modeFixed" class="btn active">Fixed UI</button>
    <button id="mode3D" class="btn">3D Follow</button>
  </div>
  <div class="label-legend">กดปุ่มสลับโหมดแสดงผลพารามิเตอร์ (คงที่ 4 มุม / ป้ายลอยใน 3D)</div>

  <script type="module">
    import * as THREE from './libs/three.module.js';
    import { OrbitControls } from './libs/OrbitControls.js';
    import { CSS2DRenderer, CSS2DObject } from './libs/CSS2DRenderer.js';

    // ===== scene / camera / renderer =====
    const el = document.getElementById('scene');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#0b0f1a');
    scene.fog = new THREE.Fog('#0b0f1a', 35, 120);

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 500);
    camera.position.set(0, 3.5, 22);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.1;
    el.appendChild(renderer.domElement);

    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(window.innerWidth, window.innerHeight);
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.top = '0';
    labelRenderer.domElement.style.left = '0';
    labelRenderer.domElement.style.pointerEvents = 'none';
    document.body.appendChild(labelRenderer.domElement);
    labelRenderer.domElement.style.display = 'none'; // เริ่มต้นเป็น Fixed UI

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.35;
    controls.minDistance = 12;
    controls.maxDistance = 40;

    // ===== lights =====
    scene.add(new THREE.AmbientLight(0xffffff, .45));
    const key = new THREE.DirectionalLight(0xffffff, 1.1);
    key.position.set(7, 8, 12);
    scene.add(key);

    // ===== heat exchanger core (กลาง) =====
    const core = new THREE.Group();
    core.position.set(0, 0.2, 0);
    const coreBox = new THREE.Mesh(
      new THREE.BoxGeometry(3.6, 3.6, 3.6),
      new THREE.MeshStandardMaterial({ color: 0x11131c, metalness: .7, roughness: .4 })
    );
    core.add(coreBox);

    const fins = new THREE.Mesh(
      new THREE.BoxGeometry(3.7, 0.05, 3.7, 20, 1, 20),
      new THREE.MeshBasicMaterial({ color: 0x0b6ef6, transparent:true, opacity:.25 })
    );
    fins.rotation.x = Math.PI/2;
    core.add(fins);

    const coreGlow = new THREE.Mesh(
      new THREE.BoxGeometry(3.9, 3.9, 3.9),
      new THREE.MeshBasicMaterial({ color: 0xff3ab5, transparent:true, opacity:.05, blending: THREE.AdditiveBlending })
    );
    core.add(coreGlow);
    scene.add(core);

    // ===== curves (ท่อ) =====
    const makeCurve = (dir=1)=> {
      const pts = [
        new THREE.Vector3(-18*dir,  2.2, -6),
        new THREE.Vector3(-10*dir,  4.0,  2),
        new THREE.Vector3( -3*dir,  1.2,  0),
        new THREE.Vector3(  0,      0.2,  0),
        new THREE.Vector3(  3*dir, -1.2,  0),
        new THREE.Vector3( 10*dir, -2.5,  2),
        new THREE.Vector3( 18*dir, -2.0,  6),
      ];
      return new THREE.CatmullRomCurve3(pts, false, 'catmullrom', 0.2);
    };
    // ตามที่คุณต้องการ: โทนเข้มเดิม
    const warmCurve = makeCurve( 1); // ซ้าย → ขวา
    const coolCurve = makeCurve(-1); // ขวา → ซ้าย

    // ===== shader (ท่อโปร่งเรือง) =====
    const tubeVert = `
      varying vec2 vUv;
      varying float vDist;
      void main() {
        vUv = uv;
        vec4 mv = modelViewMatrix * vec4(position, 1.0);
        vDist = -mv.z;
        gl_Position = projectionMatrix * mv;
      }`;
    const tubeFrag = `
      precision highp float;
      uniform float uTime;
      uniform vec3 uColorA;
      uniform vec3 uColorB;
      uniform float uGlow;
      varying vec2 vUv;
      varying float vDist;

      float stripe(float x, float sp){
        return smoothstep(0.0, 0.02, fract(x - sp)) - smoothstep(0.02, 0.04, fract(x - sp));
      }

      void main(){
        float t = smoothstep(0.33, 0.67, vUv.x);
        vec3 base = mix(uColorA, uColorB, t);

        float s1 = stripe(vUv.x, uTime * 0.18);
        float s2 = stripe(vUv.x, uTime * 0.26 + 0.37);
        float flow = s1 + s2;

        float edge = pow(1.0 - abs(vUv.y - 0.5) * 2.0, 3.0);
        float depthFade = clamp(vDist * 0.02, 0.0, 1.0);

        vec3 color = base * 1.15 + (flow * 1.7 + edge * uGlow) * base;
        gl_FragColor = vec4(color, 0.78 * depthFade);
      }`;

    function makeTube(curve, colorA, colorB) {
      const geom = new THREE.TubeGeometry(curve, 400, 0.55, 20, false);
      const mat = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uColorA: { value: new THREE.Color(colorA) },
          uColorB: { value: new THREE.Color(colorB) },
          uGlow:  { value: 2.4 } // เอฟเฟกต์เรืองนุ่ม
        },
        transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
        vertexShader: tubeVert, fragmentShader: tubeFrag
      });
      const mesh = new THREE.Mesh(geom, mat);
      return { mesh, material: mat };
    }

    // สีตามที่คุณล็อกไว้ (เข้ม/คุมโทน)
    const warm = makeTube(warmCurve, '#b8321a', '#1874d2'); // แดงเข้ม → ฟ้าเข้ม
    const cool = makeTube(coolCurve, '#1874d2', '#b8321a'); // ฟ้าเข้ม → แดงเข้ม
    scene.add(warm.mesh, cool.mesh);

    // ===== particles (ไหลไปตามท่อ) =====
    function makeFlowParticles(curve, color, count=900){
      const g = new THREE.BufferGeometry();
      const ts = new Float32Array(count);
      const speeds = new Float32Array(count);
      const offs = new Float32Array(count);
      for (let i=0;i<count;i++){
        ts[i] = Math.random();
        speeds[i] = 0.05 + Math.random()*0.15;
        offs[i] = (Math.random()-0.5)*0.6;
      }
      g.setAttribute('t', new THREE.BufferAttribute(ts,1));
      g.setAttribute('speed', new THREE.BufferAttribute(speeds,1));
      g.setAttribute('off', new THREE.BufferAttribute(offs,1));
      g.setAttribute('position', new THREE.BufferAttribute(new Float32Array(count*3),3));
      const m = new THREE.PointsMaterial({ size:0.09, color, transparent:true, opacity:0.9, blending:THREE.AdditiveBlending });
      const p = new THREE.Points(g, m);
      p.userData.curve = curve;
      return p;
    }
    const warmDots = makeFlowParticles(warmCurve, new THREE.Color('#e46a55'));
    const coolDots = makeFlowParticles(coolCurve, new THREE.Color('#6aa9e8'));
    scene.add(warmDots, coolDots);

    // ===== จุด world สำหรับติดป้าย 3D (ตำแหน่ง 4 จุด) =====
    // ใช้สัดส่วนบนเส้นโค้ง: 0 (ต้นทาง) / 1 (ปลายทาง)
    const P = {
      warmIn : new THREE.Object3D(),
      warmOut: new THREE.Object3D(),
      coolIn : new THREE.Object3D(),
      coolOut: new THREE.Object3D(),
    };
    P.warmIn.position.copy( warmCurve.getPointAt(0.02) );
    P.warmOut.position.copy(warmCurve.getPointAt(0.98) );
    P.coolIn.position.copy( coolCurve.getPointAt(0.02) );
    P.coolOut.position.copy(coolCurve.getPointAt(0.98) );
    Object.values(P).forEach(o=>scene.add(o));

    // ===== ค่าตัวอย่าง (เชื่อมจริงภายหลังได้) =====
    const data = {
      warmIn : { t: 32, h: 40 },
      warmOut: { t: 24, h: 55 },
      coolIn : { t: 18, h: 60 },
      coolOut: { t: 23, h: 50 },
      unitT: '°C', unitH: '%RH'
    };

    // เติมค่าลง Fixed HUD
    const $ = (id)=>document.getElementById(id);
    $('fiT').textContent = `${data.warmIn.t}${data.unitT}`;
    $('fiH').textContent = `${data.warmIn.h}${data.unitH}`;
    $('foT').textContent = `${data.warmOut.t}${data.unitT}`;
    $('foH').textContent = `${data.warmOut.h}${data.unitH}`;
    $('ciT').textContent = `${data.coolIn.t}${data.unitT}`;
    $('ciH').textContent = `${data.coolIn.h}${data.unitH}`;
    $('coT').textContent = `${data.coolOut.t}${data.unitT}`;
    $('coH').textContent = `${data.coolOut.h}${data.unitH}`;

    // ===== ป้าย 3D (CSS2D) =====
    function makeTag(label, v, kind/* 'warm'|'cool' */){
      const div = document.createElement('div');
      div.className = `tag ${kind}`;
      div.innerHTML = `<span class="t3d">${v.t}${data.unitT}</span><span class="rh">${v.h}${data.unitH}</span><div style="opacity:.7;font-size:11px;margin-top:2px">${label}</div>`;
      return new CSS2DObject(div);
    }
    const L = {
      warmIn : makeTag('Warm Inlet',  data.warmIn , 'warm'),
      warmOut: makeTag('Cool Outlet', data.warmOut, 'cool'),
      coolIn : makeTag('Cool Inlet',  data.coolIn , 'cool'),
      coolOut: makeTag('Warm Outlet', data.coolOut, 'warm'),
    };
    L.warmIn.position.copy( P.warmIn.position );   scene.add(L.warmIn);
    L.warmOut.position.copy(P.warmOut.position);   scene.add(L.warmOut);
    L.coolIn.position.copy( P.coolIn.position );   scene.add(L.coolIn);
    L.coolOut.position.copy(P.coolOut.position);   scene.add(L.coolOut);

    // เริ่มต้นซ่อนไว้ เพราะเริ่มที่ Fixed UI
    labelRenderer.domElement.style.display = 'none';
    Object.values(L).forEach(obj => { obj.visible = false; });

    // ===== Toggle Mode =====
    const fixedHud = document.getElementById('fixedHud');
    const btnFixed = document.getElementById('modeFixed');
    const btn3D    = document.getElementById('mode3D');

    let mode = 'fixed'; // 'fixed' | 'follow'

    function setMode(next){
      mode = next;
      const isFixed = mode==='fixed';
      fixedHud.style.display = isFixed ? 'block':'none';
      btnFixed.classList.toggle('active', isFixed);
      btn3D.classList.toggle('active', !isFixed);

      labelRenderer.domElement.style.display = isFixed ? 'none':'block';
      Object.values(L).forEach(obj => { obj.visible = !isFixed; });
    }

    btnFixed.addEventListener('click', ()=> setMode('fixed'));
    btn3D.addEventListener('click', ()=> setMode('follow'));

    // ===== animate =====
    const clock = new THREE.Clock();
    function updateParticles(points, delta) {
      const curve = points.userData.curve || (points === warmDots ? warmCurve : coolCurve);
      const pos = points.geometry.attributes.position;
      const tAttr = points.geometry.getAttribute('t');
      const speedAttr = points.geometry.getAttribute('speed');
      const offAttr = points.geometry.getAttribute('off');

      for (let i=0; i<tAttr.count; i++) {
        let t = tAttr.getX(i);
        t += speedAttr.getX(i) * delta * 0.15;
        if (t>1) t -= 1;
        tAttr.setX(i, t);

        const p = curve.getPointAt(t);
        const n = curve.getTangentAt(Math.max(0.0, t-0.001)).clone().cross(new THREE.Vector3(0,1,0)).normalize();
        const o = offAttr.getX(i);
        pos.setXYZ(i, p.x + n.x*o, p.y + Math.sin(t*20.0 + i)*0.1, p.z + n.z*o);
      }
      pos.needsUpdate = true;
      tAttr.needsUpdate = true;
    }

    function animate(){
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      const elapsed = clock.elapsedTime;
      warm.material.uniforms.uTime.value = elapsed;
      cool.material.uniforms.uTime.value = elapsed;

      updateParticles(warmDots, dt);
      updateParticles(coolDots, dt);

      controls.update();
      renderer.render(scene, camera);
      if (mode==='follow') labelRenderer.render(scene, camera);
    }
    animate();

    // ===== resize =====
    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      labelRenderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
